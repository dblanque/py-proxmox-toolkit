from ..debian.constants import FILE_NETWORK_INTERFACES
from ..network.interfaces import NETWORK_INTERFACES_INET_TYPES
import re
from os.path import isfile

DEFAULT_PVE_HEADER = """# network interface settings; autogenerated
# Please do NOT modify this file directly, unless you know what
# you're doing.
#
# If you want to manage parts of the network configuration manually,
# please utilize the 'source' or 'source-directory' directives to do
# so.
# PVE will preserve these directives, but will NOT read its network
# configuration from sourced files, so do not attempt to move any of
# the PVE managed interfaces into external files!
#
# Auto-Generation modified by py-proxmox-toolkit
# """

TOP_LEVEL_LONE_ARGS = ["source", "mapping", "rename"]

TOP_LEVEL_IFACE_BOOL = [
	"auto",
	"allow-auto",
	"allow-hotplug",
]

TOP_LEVEL_IFACE_ARGS = ["iface", *TOP_LEVEL_IFACE_BOOL]

INITIAL_ARGS = [*TOP_LEVEL_IFACE_ARGS, *TOP_LEVEL_LONE_ARGS]


class NetworkInterfacesParseException(Exception):
	pass


def parse_interfaces(
	file=FILE_NETWORK_INTERFACES,
) -> tuple[
		dict[str, dict[str, str]],
		dict[str, list[list[str]]]
	]:
	"""
	Parses /etc/network/interfaces file.
	:return: interfaces, top_level_arguments
	:rtype: tuple
	"""
	ifaces = {}
	top_level_args = {}
	if not isfile(file):
		raise Exception(f"{file} does not exist.")
	with open(file, "r") as f:
		iface_name: str | None = None
		for line in f.readlines():
			line = line.strip()
			if len(line) <= 0:
				continue
			try:
				l_args = line.split()
				param: str = l_args[0].strip()

				if param in TOP_LEVEL_LONE_ARGS:
					if param not in top_level_args:
						top_level_args[param] = []
					top_level_args[param].append(l_args[1:])
				elif param.startswith("#") and not iface_name:
					continue
				elif param == "iface":
					if l_args[1] not in ifaces:
						ifaces[l_args[1]] = {}
					iface_name = l_args[1]
					ifaces[iface_name]["name"] = iface_name

					if l_args[-1] not in NETWORK_INTERFACES_INET_TYPES:
						raise NetworkInterfacesParseException(
							"Invalid network interface type."
						)
					else:
						ifaces[iface_name]["type"] = l_args[-1]
				elif param in TOP_LEVEL_IFACE_BOOL:
					if l_args[1] not in ifaces:
						ifaces[l_args[1]] = {}
					ifaces[l_args[1]][param] = True
				elif param.startswith("#"):
					if "description" in ifaces[iface_name] and (
						ifaces[iface_name]["description"]
						or len(ifaces[iface_name]["description"]) > 1
					):
						raise NetworkInterfacesParseException(
							"A network interface has multiple descriptions.",
							ifaces[iface_name]["description"],
						)
					ifaces[iface_name]["description"] = re.sub(r"^(#+)(.*)$", "\\2", line)
					iface_name = None
				elif iface_name:
					ifaces[iface_name][param] = l_args[1:]
			except:
				print("Offending line:")
				print(line)
				raise
	return ifaces, top_level_args


def stringify_interfaces(
	network_interfaces_dict: dict, top_level_args: dict, sort_function=None
) -> str:
	output = DEFAULT_PVE_HEADER
	if sort_function:
		network_interfaces_keys_sorted = sorted(
			network_interfaces_dict.keys(), key=sort_function
		)
	for iface_key in network_interfaces_keys_sorted:
		iface_dict: dict = network_interfaces_dict[iface_key]
		line = ""
		try:
			iface_name = iface_dict.pop("name")
			iface_type = iface_dict.pop("type")
		except:
			print(iface_key)
			print(iface_dict)
			raise
		for bool_arg in TOP_LEVEL_IFACE_BOOL:
			if bool_arg in iface_dict:
				iface_dict.pop(bool_arg)
				line = f"{line}\n{bool_arg} {iface_name}"

		line = f"{line}\niface {iface_name} inet {iface_type}"
		output = f"{output}\n{line}"
		for k, v in iface_dict.items():
			if k == "description":
				v: str
				output = f"{output}\n#{v.strip()}"
			else:
				try:
					output = f"{output}\n\t{k} {' '.join([str(e) for e in v]).strip()}"
				except:
					print("Offending value:")
					print(v)
					raise

	output = f"{output}\n"
	for stanza, arg_values in top_level_args.items():
		for v in arg_values:
			output = f"{output}\n{stanza} {' '.join([str(e) for e in v]).strip()}"

	return f"{output}\n"
